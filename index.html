<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>MVC Module Magic | Alex Sexton | Backboneconf 2012</title>

    <meta name="description" content="Using modules in your MVC apps in order to facilitate natural structure, easy builds, and transparent middleware.">
    <meta name="author" content="Alex Sexton">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link href='css/fonts.css' rel='stylesheet' type='text/css'>
    <!-- link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css' -->

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/print.css" type="text/css" media="print">

    <link rel="stylesheet" href="lib/zenburn.css">
    <style type="text/css">
      body #reveal .slides {
        width : 1280px;
        margin-left : -640px;
      }
      #reveal pre code {
        font-size : 34px;
        line-height : 38px;
        -webkit-filter: invert(1);
      }
      #reveal pre.thin {
        width: 67%;
      }
      #reveal .oneliner {
        padding-top : 20%;
        font-size : 1.4em;
      }
      #reveal .oneliner h3 {
        line-height: 1;
      }
      body #reveal em {
        font-style : normal;
        font-size : 1.2em;
        color : #A6E22E;
      }
      body #reveal .oneliner em {
        text-transform : uppercase;
        font-weight : bold;
      }
    </style>
  </head>

  <body>

    <div id="reveal">

      <!-- Used to fade in a background when a specific slide state is reached -->
      <div class="state-background"></div>

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <section data-markdown>
            # MVC Module Magic

            <br />

            ### App Structurizer, Build Easifier,
            ### &amp; Middleware Magician

            <script>
              // Delicously hacky. Look away.
            if( navigator.userAgent.match( /(iPhone|iPad|iPod|Android)/i ) ) document.write( '<p style="color: rgba(0,0,0,0.3); text-shadow: none;">('+'Tap to navigate'+')</p>' );
            </script>
          </section>

          <section data-markdown>
            # MVWTF Module Magic

            <br />

            ### App Structurizer, Build Easifier,
            ### &amp; Middleware Magician
          </section>
        </section>

        <section data-markdown>
          # Alex Sexton

          ## &nbsp;

          * Senior UI Developer @ Bazaarvoice
          * Modernizr and jQuery/yayQuery team member
          * yepnope.js, Jed, MessageFormat.js
        </section>

        <section data-markdown>
          ## Modules are not new

          <br />
          <pre class="thin"><code contenteditable>function Module () {
            return {
              someStuff: { ... }
            };
          }
          </code></pre>

          <br />

          So what do they have to do with my MVWTF apps?
        </section>

        <section data-markdown>
          ![/img/brain.jpg](/img/brain.jpg)
          <br />

          Your need for modules is directly related to how much of your app you can hold in your head at once.
        </section>

        <section data-markdown class="oneliner">
          The *MVWTF* pattern is appealing for large applications and encourages code reuse &amp; separation of concerns.
        </section>

        <section data-markdown>
          # In other words

          <br />

          ### Modules and MVWTF Apps
          ### *were made for each other*
        </section>

        <section data-markdown class="oneliner">
          # App Structure
        </section>

        <section data-markdown>
          ## All too common

          <br />
          <pre class="thin"><code contenteditable>|+ App
          &nbsp;|- app.js
           |- controllers.js
           |- models.js
           |- views.js
           |- index.html
          </code></pre>

          <br />

          ### *Dependency management hell*
        </section>

        <section data-markdown class="oneliner">
          ## How about a module per file?
        </section>

        <section>
          <section data-markdown>
            ## Option 1

            <br />
            <pre><code contenteditable>var UserModel = require('Models/User');
            var UserView  = require('Views/User');
            </code></pre>

            Which results in this file structure

            <pre class="thin"><code contenteditable>|+ App
            &nbsp;|+ Models
              |- User.js
             |+ Views
              |- User.js
            </code></pre>

          </section>

          <section data-markdown>
            ## Option 2

            <br />
            <pre><code contenteditable>var UserModel = require('User/Model');
            var UserView  = require('User/View');
            </code></pre>

            Which results in this file structure

            <pre class="thin"><code contenteditable>|+ App
            &nbsp;|+ User
              |- Model.js
              |- View.js
            </code></pre>
          </section>

          <section data-markdown>
            ## Option 3

            <br />
            <pre><code contenteditable>var UserModel = require('UserModel');
            var UserView  = require('UserView');
            </code></pre>

            Which results in this file structure

            <pre class="thin"><code contenteditable>|+ App
            &nbsp;|- UserModel.js
             |- UserView.js
            </code></pre>
          </section>
        </section>

        <section data-markdown class="oneliner">
          ## Now it's much easier to find things. *promise*.
        </section>

        <section data-markdown class="oneliner">
          ## *perks*.
        </section>

<!--
        # App Structure

        poor performance

        Side-benefit - anonymous module declarations based on file name

        Regardless, you have atomic files for each component. This is often key to builds and actually reusing code. It even helps
        debugging and learning curves.

        Doesn't necessarily need to be coupled to the file system.

          - Paths
            - Last minute aliasing  "underscore" : "lodash"
            - Prettier paths for custom file systems "templates/" : "../../templates/"

        Most module systems will allow you to have a nice naming mechanism for sub-modules, etc

          - require('jquery');
          - require('jquery/ui');
          - require('jquery/ui/draggable');

        |-  jquery.js
        |+ jquery
         |-  ui.js
         |+ ui
          |-  draggable.js

        In the end, you're left with easily traversable files that describe their contents, and most importantly, each maintain their own dependencies.


        # Templates never have a place to fit

        Tired of
          - &lt;script type="text/tmpl"&gt;{{tmpl}}&lt;/script&gt;

        This does not scale. Templates are dependencies like anything else. Styles are too, for that matter. Let's get them integrated into our system.

        During local development templates can be ajax'd in or included as a runtime built output.

        # AMD Tangent

        I use AMD. RequireJS specifically.

        I think it's the best solution for modules on the web that we currently have.

        I have a lengthy blog post on the subject: http://alexsexton.com/blog/2012/03/my-thoughts-on-amd/

        I think it's fine as a compilation target if you hate the syntax. But I like the idea of a unified compile target.
          * var x = require('x') to require(['x'], function (x) { ... }) is a trivial compilation.

        The plugin system is killer. Seriously. I'll show you in a bit.

        The web is async. Forcing a sync pattern where an asynchronous one is natural leads to (my) confusion, potentially others.

        Ember does a good job of AMD as a compilation target with Ember.amd.js - doesn't need to be incredibly granularly exposed.

        There are clear clear patterns for safely supporting AMD with node and globals, etc at the same time. Comments otherwise are FUD.

        Use.js can be used to use unmodified source of modules that are not AMD modules. I prefer to just add it. It's easy.

        Build.sh has to go away. We need a complex dependency management solution.

        Browserify can only handle part of the problem. Works for many apps though.

        The BOILERPLATE argument is weird:
          AMD is less characters than known alternatives. Can't use 'builds' as an excuse cause i could preprocess too.

        AMD has the benefit of also working on the serverside as naturally as it does on the client. - kind of not a big deal.

        So from now on I'm going to use examples with AMD. Nearly everything is possible via other module systems, but my examples are actually already implemented in
        require.js, etc.

        ES Harmony Modules look cool, but aren't currently viable/stable. Use those when they are.


        # Getting rid of boilerplate

        ES6/Harmony is all about getting rid of syntax boilerplate. But we have much more boilerplate in our MVWTF apps.

        consider, this extremely common practice:

        define('view/main', ['backbone', 'handlebars', 'text!tmpl/one'], function (Backbone, Handlebars, oneTxt) {
          return Backbone.view.extend({
            initialize : function () {
              this.template = Handlebars.compile(oneTxt);
            },
            ...
          });
        });

        vs.

        // Require this with a v! plugin
        define(['hbs!tmpl/one'], function (tmpl) {
          return {
            initialize : function () {
              this.template = tmpl;
            },
            ...
          }
        });

        // Has the added benefit of being smaller (take out handlebars compile/parse) and faster (precompiled) all in way less code.

        PROGRAM AWAY YOUR BOILERPLATE


        # AMD Plugins

        plugin BANG

        An AMD plugin is essentially a way to inject middleware into your dependency management system.

        Think connect.js for your modules.

        If you always do something to a module after you request it, you can make RequireJS do it for you transparently.

        You define when the dependency is resolved asynchronously.

        These runtime decisions can be baked after a build.

        The plugin name describes where the loading plugin lives, and the rest is sent as a key, usually still mapped to the file system, but not necessarily.

        In the case of use.js the pattern is:
        require('use!backbone.js', function (Backbone) {});

        use.js:
          - load backbone.js (remember, you explicitly tell the plugin when you have a response, so you can load as much as you want.)
          - after execution:
            - return window.Backbone as the module
            - optionally clean up the global.


        # Builds

        Built for performance

        You can make templates dependencies. You can give templates style dependencies and handle this then.
        You can run a precompiler on your templates at build time. Then remove the parser and compiler.
        Then you can inject only the styles you need as an app dependency (a string) as well.
        Then you can inject those styles as a style element.
        With data uris and fonts, you can get down to a single request.

        Build Profiles

        - has.js plugins
        - dead code removal
        - jensarps/AMD-feature
          - IE specific builds
          - Mobile specific builds (paths: ['jquery' : 'zepto'])

          - use a scout file in order to handle caching and profile branching.


        # Plugins as a vehicle for static compilation at build time
          - templates
          - i18n
          - i18n in templates
          - configurable apps. multi-profile apps.
          - coffeescript
          - less.js

          EXAMPLES

          SPEED SIZE CRAZINESS

          Anything that you _can_ precompute at build time should optimally be done at build time.
          -->

        <section data-markdown>
          ## title
        </section>


        <section data-markdown>
          ## Lynx

          * [alexsexton.com](http://alexsexton.com)
          * [@slexaxton](http://twitter.com/slexaxton)
          * [github.com/slexaton](https://github.com/slexaxton)
        </section>

        <section data-markdown>
          # THE END

          ### BY Alex Sexton / alexsexton.com
        </section>
      </div>

      <!-- The navigational controls UI -->
      <aside class="controls">
        <a class="left" href="#">&#x25C4;</a>
        <a class="right" href="#">&#x25BA;</a>
        <a class="up" href="#">&#x25B2;</a>
        <a class="down" href="#">&#x25BC;</a>
      </aside>

      <!-- Displays presentation progress, max value changes via JS to reflect # of slides -->
      <div class="progress"><span></span></div>

    </div>

    <script src="js/reveal.js"></script>

    <!-- Optional libraries for code syntax highlighting and classList support in IE9 -->
    <script src="lib/highlight.js"></script>
    <script src="lib/classList.js"></script>

    <script>
      // Parse the query string into a key/value object
    var query = {};
    location.search.replace( /[A-Z0-9]+?=(\w*)/gi, function(a) {
        query[ a.split( '=' ).shift() ] = a.split( '=' ).pop();
        } );

    // Fires when a slide with data-state=customevent is activated
    Reveal.addEventListener( 'customevent', function() {
        alert( '"customevent" has fired' );
        } );

    // Fires each time a new slide is activated
    Reveal.addEventListener( 'slidechanged', function( event ) {
        // event.indexh & event.indexv
        } );

    Reveal.initialize({
        // Display controls in the bottom right corner
    controls: true,

    // Display a presentation progress bar
    progress: true,

    // If true; each slide will be pushed to the browser history
    history: true,

    // Loops the presentation, defaults to false
    loop: false,

    // Flags if mouse wheel navigation should be enabled
    mouseWheel: true,

    // Apply a 3D roll to links on hover
    rollingLinks: true,

    // UI style
    theme: query.theme || 'default', // default/neon

    // Transition style
    transition: query.transition || 'default' // default/cube/page/concave/linear(2d)
    });

    hljs.initHighlightingOnLoad();

    (function boom(){

     if (!window.Showdown){
     var scr = document.createElement('script');
     scr.onload = boom;
     scr.src = '/js/showdown.js';
     document.body.appendChild(scr);
     return;
     }

     [].forEach.call( document.querySelectorAll('[data-markdown]'), function  fn(elem){

       // strip leading whitespace so it isn't evaluated as code
       var text      = elem.innerHTML.replace(/\n\s*\n/g,'\n'),
       // set indentation level so your markdown can be indented within your HTML
       leadingws = text.match(/^\n?(\s*)/)[1].length,
       regex     = new RegExp('\\n?\\s{' + leadingws + '}','g'),
       md        = text.replace(regex,'\n'),
       html      = (new Showdown.converter()).makeHtml(md);

       // here, have sum HTML
       elem.innerHTML = html;

       });

     }());
 </script>

  </body>
</html>
